#@ !  This file was generated by kMOS (kMC modelling on steroids)
#@ !  written by Andreas Garhammer (C) 2015-2016.
#@ !
#@ !  This file is part of kmos.
#@ !
#@ !  kmos is free software; you can redistribute it and/or modify
#@ !  it under the terms of the GNU General Public License as published by
#@ !  the Free Software Foundation; either version 2 of the License, or
#@ !  (at your option) any later version.
#@ !
#@ !  kmos is distributed in the hope that it will be useful,
#@ !  but WITHOUT ANY WARRANTY; without even the implied warranty of
#@ !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#@ !  GNU General Public License for more details.
#@ !
#@ !  You should have received a copy of the GNU General Public License
#@ !  along with kmos; if not, write to the Free Software
#@ !  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
#@ !  USA
#@ !****h* kmos/base_acf
#@ ! FUNCTION
#@ !    Implements the tracking process for particles of a defined species (tracked species)
#@ !    in the case of  diffusion processes (which particle is on which site after a kMC step). 
#@ !    Using this module each site can be specified with a property
#@ !    and one can calculate the autocorrelation function (Integral(g(0)g(t)dt)) between 
#@ !    a porperty at time zero (g(0)) and properties at later times (g(t)).
#@ !    The autocorrelation function in this module is a average over all particles
#@ !    of the tracked species.
#@ !    Furthermore one can record the displacement for every particle of the tracked species
#@ !    and calculate the mean squared displacement as a average over all these particles.
#@ !    Additionally, it is possible to record the trajectory for every particle of the
#@ !    tracked species (save for every step and every particle the site index).
#@ !   
#@ !    The feature acf in kmos works for the following cases: 
#@ !    
#@ !    * Sampling of the autocorrelation function (ACF):
#@ !      It is possible to sample the ACF for one species (tracked species).
#@ !      The number of particles of this species can be constant or can change
#@ !      (source and drain processes) during the simulation. Particles of other species
#@ !      can also move, but the number of these particles has to be constant during the
#@ !      simulation. Furthermore, one can record the trajectory of particles, which
#@ !      correspond to the tracked species in the case of a constant particle number
#@ !      during the simulation.
#@ ! 
#@ !    * Sampling of mean squared displacement (MSD):
#@ !      It is possible to sample the MSD for one species (tracked species).
#@ !      The number of particles of this species has to be constant during the simulation.
#@ !      Particles of other species can also move, but the number of these particles also
#@ !      has to be constant during the simulation. Furthermore, one can record the trajectory
#@ !      of particles, which correspond to the tracked species in the case of a constant 
#@ !      particle number during the simulation.
#@ !******
#@ 
#@ 
#@ module base_acf
#@ use kind_values
#@ use base
#@ 
#@ 
#@ 
#@ !------ No implicit definition of variables !
#@ implicit none
#@  
#@ 
#@ !------ A. Garhammer 2015------
#@ integer(kind=iint), dimension(:), allocatable :: id_arr
#@ !****v* base_acf/id_arr
#@ ! FUNCTION
#@ !   Stores id of the particle of the tracked species, which occupies a site.
#@ !******
#@ !------ A. Garhammer 2016------
#@ integer(kind=iint), dimension(:), allocatable :: site_arr
#@ !****v* base_acf/site_arr
#@ ! FUNCTION
#@ !   Stores site index, for every particle id of the tracked species.
#@ !******
#@ !------ A. Garhammer 2016------
#@ real(kind=rdouble), dimension(:,:), allocatable :: displacement
#@ !****v* base_acf/displacement
#@ ! FUNCTION
#@ !   Stores the displacement for each particle of the tracked species.
#@ !******
#@ !------ A. Garhammer 2015------
#@ integer(kind=iint), dimension(:), allocatable :: property_acf
#@ !****v* base_acf/property_acf
#@ ! FUNCTION
#@ !   Stores type_index of the corresponding property of each site.
#@ !******
#@ !------ A. Garhammer 2015------
#@ integer(kind=iint), dimension(:), allocatable :: property_o
#@ !****v* base_acf/property_o
#@ ! FUNCTION
#@ !   Stores for each particle the initial property between two decorrelation times.
#@ !******
#@ !------ A. Garhammer 2016------
#@ real(kind=rdouble), dimension(:), allocatable :: types
#@ !****v* base_acf/types
#@ ! FUNCTION
#@ !   Stores all possible properties.
#@ !******
#@ !------ A. Garhammer 2016------
#@ real(kind=rdouble), dimension(:, :), allocatable :: product_property
#@ !****v* base_acf/product_property
#@ ! FUNCTION
#@ !   Stores the product of all possible combinations between two properties.
#@ !******
#@ !------ A. Garhammer 2015------
#@ integer(kind=iint), dimension(:, :), allocatable :: trajectory
#@ !****v* base_acf/trajectory
#@ ! FUNCTION
#@ !   Stores the trajectory (site index for every kmc step) for each particle.
#@ !******
#@ !------ A. Garhammer 2016------
#@ real(kind = rdouble), dimension(:), allocatable :: buffer_acf
#@ !****v* base_acf/buffer_acf
#@ ! FUNCTION
#@ !   Stores the product between the initial property_o and the current property for each particle
#@ !   of the tracked species.
#@ !******
#@ !------ A. Garhammer 2016------
#@ real(kind = rdouble), dimension(:), allocatable :: config_bin
#@ !****v* base_acf/config_bin
#@ ! FUNCTION
#@ !   Stores the property average over all particles and all wraps for every bin.
#@ !******
#@ !------ A. Garhammer 2016------
#@ integer(kind = iint), dimension(:), allocatable :: counter_write_in_bin
#@ !****v* base_acf/counter_write_in_bin
#@ ! FUNCTION
#@ !   Stores number of contributions to a bin.
#@ !******
#@ !------ A. Garhammer 2016------
#@ integer(kind = iint) :: nr_of_types
#@ !****v* base_acf/nr_of_types
#@ ! FUNCTION
#@ !   Stores number of different types of porperties.
#@ !******
#@ !------ A. Garhammer 2015------
#@ integer(kind = iint) :: nr_of_ions
#@ !****v* base_acf/nr_of_ions
#@ ! FUNCTION
#@ !   Stores the number of ions in the lattice.
#@ !******
#@ !------ A. Garhammer 2016------
#@ integer(kind = iint) :: nr_of_ions_before_kmc_step_acf
#@ !****v* base_acf/nr_of_ions_before_kmc_step_acf
#@ ! FUNCTION
#@ !   Stores the number of ions which contributes to the ACF.
#@ !******
#@ !------ A. Garhammer 2016------
#@ integer(kind = iint) :: bin_index
#@ !****v* base_acf/bin_index
#@ ! FUNCTION
#@ !   Index of bin which is needed for the calculation of the ACF.
#@ !******
#@ !------ A. Garhammer 2016------
#@ integer(kind = iint) :: extended_nr_of_bins
#@ !****v* base_acf/extended_nr_of_bins
#@ ! FUNCTION
#@ !   Number of bins after the multiplication with safety factor.
#@ !******
#@ !------ A. Garhammer 2016------
#@ integer(kind = iint) :: nr_of_bins
#@ !****v* base_acf/nr_of_bins
#@ ! FUNCTION
#@ !   Number of bins for the calculation of the ACF.
#@ !******
#@ !------ A. Garhammer 2016------
#@ real(kind=rdouble) :: t_bin
#@ !****v* base_acf/t_bin
#@ ! FUNCTION
#@ !   Bin size in s.
#@ !******
#@ !------ A. Garhammer 2016------
#@ real(kind=rdouble) :: t_f
#@ !****v* base_acf/t_f
#@ ! FUNCTION
#@ !   Decorrelation time of the ACF in s, which is given by the user.
#@ !******
#@ !------ A. Garhammer 2016------
#@ real(kind=rdouble) :: t_o
#@ !****v* base_acf/t_o
#@ ! FUNCTION
#@ !  Stores the new starting time after the decorrelation of one cycle was reached.
#@ !******
#@ !------ A. Garhammer 2016------
#@ real(kind=rdouble) :: wrap_count
#@ !****v* base_acf/wrap_count
#@ ! FUNCTION
#@ !  Number of wraps for the time average of every bin.
#@ !******
#@ !------ A. Garhammer 2015------
#@ integer(kind=ilong) :: kmc_step_acf
#@ !****v* base_acf/kmc_step_acf
#@ ! FUNCTION
#@ !   Number of kMC steps executed for the calculation of acf.
#@ !******
#@ !------ A. Garhammer 2015------
#@ integer(kind=iint) :: nr_of_steps
#@ !****v* base_acf/nr_of_steps
#@ ! FUNCTION
#@ !   Number of kMC steps for which the trajectory is recorded.
#@ !******
#@ !------ A. Garhammer 2016------
#@ real(kind=rdouble) :: nr_of_annhilations
#@ !****v* base_acf/nr_of_annhilations
#@ ! FUNCTION
#@ !   Number of annhilations.
#@ !******
#@
#@ 
#@ !****************
#@ contains
#@ !****************
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine calc_nr_of_ions(trace_species)
#@ !****f* base_acf/calc_nr_of_ions
#@ ! FUNCTION
#@ !    Calculates the number of ions of the tracked species.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``trace_species`` positive integer number that represents the species which is tracked.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind = iint) :: k, species, volume
#@ integer(kind = iint), intent(in) :: trace_species
#@ 
#@ nr_of_ions = 0
#@ 
#@ call get_volume(volume)
#@ 
#@ do k = 1, volume
#@   species = get_species(k)
#@ if( species == trace_species )then
#@ nr_of_ions = nr_of_ions + 1
#@ endif
#@ enddo
#@  
#@ end subroutine calc_nr_of_ions
#@ 
#@ subroutine update_nr_of_ions_before_kmc_step_acf()
#@ !****f* base_acf/update_nr_of_ions_before_kmc_step_acf
#@ ! FUNCTION
#@ !    
#@ ! ARGUMENTS
#@ !    * ``none``   
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ nr_of_ions_before_kmc_step_acf = nr_of_ions
#@  
#@ end subroutine update_nr_of_ions_before_kmc_step_acf
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine get_nr_of_ions(return_nr_of_ions)
#@ !****f* base_acf/get_nr_of_ions
#@ ! FUNCTION
#@ !    Returns current number of ions of the tracked_species as iint integer as defined in kind_values.f90.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``return_nr_of_ions`` writeable integer, where the nr_of_ions will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind=iint), intent(out) :: return_nr_of_ions
#@  
#@ return_nr_of_ions = nr_of_ions
#@ 
#@ end subroutine get_nr_of_ions
#@  
#@ !------ A. Garhammer 2015------
#@ subroutine initialize_acf(trace_species)
#@ !****f* base_acf/initialize_acf
#@ ! FUNCTION
#@ !    initialize_acf allocates and initializes the arrays for calculating the autocorrelation function (ACF).
#@ !    The subroutine assigns each particle (trace_species) an id for the initial state and saves this id in id_arr.
#@ !    The user have to call this subroutine, before the kmc run can start to calculate the ACF
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``trace_species`` positive integer number that represents the species which is tracked.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind = iint) :: k, i, volume, species
#@ integer(kind = iint), intent(in) :: trace_species
#@ 
#@ !Calculation of the number of ions
#@ call calc_nr_of_ions(trace_species)
#@ nr_of_ions_before_kmc_step_acf = nr_of_ions
#@ 
#@ !allocates the arrays for the autocorrelationfunction and initialize with 0
#@ call get_volume(volume)
#@  
#@ !Start initialization process for id_arr and trajectory
#@ i = 1
#@ do k = 1, volume
#@   species = get_species(k)
#@ if( species == trace_species )then
#@ id_arr(k) = i
#@ site_arr(i) = k
#@ i = i + 1
#@ else
#@ id_arr(k) = 0
#@ endif
#@ enddo
#@ 
#@ call update_property_and_buffer_acf()
#@  
#@ end subroutine initialize_acf
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine initialize_mean_squared_displacement(trace_species)
#@ !****f* base_acf/initialize_mean_squared_displacement
#@ ! FUNCTION
#@ !    initialize_mean_squared_displacement allocates and initializes the arrays for calculating the mean squared displacement.
#@ !    The subroutine assigns each particle (trace_species) an id for the initial state and saves this id in id_arr.
#@ !    The user must specify the species to be used for calculating the mean squared displacement.
#@ !    The arrays start from index zero not from one. 
#@ !    In the case of diffusion processes of other species than the tracked species, one need dummy entries at index zero.
#@ !    These entries remain zero all the time with exception of the entry of the array displacement at index zero. In this
#@ !    entry, the displacment of the particles of other species than the tracked species will be stored.
#@ !    Otherwise the tracking of the particles doesn't work in this case.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``trace_species`` positive integer number that represents the species which is tracked.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind = iint) :: k, i, volume, species
#@ integer(kind = iint), intent(in) :: trace_species
#@
#@ !Calculation of the number of ions
#@ call calc_nr_of_ions(trace_species)
#@ call get_volume(volume)
#@  
#@ allocate(id_arr(0:volume))
#@ id_arr = 0
#@ 
#@ allocate(site_arr(0:volume))
#@ site_arr = 0
#@ 
#@ allocate(displacement(0:nr_of_ions, 3))
#@ displacement = 0
#@ 
#@ !Start initialization process for id_arr
#@ i = 1
#@ do k = 1, volume
#@    species = get_species(k)
#@ if( species == trace_species )then
#@ id_arr(k) = i
#@ site_arr(i) = k
#@ i = i + 1
#@ else
#@ id_arr(k) = 0
#@ endif
#@ enddo
#@ 
#@ end subroutine initialize_mean_squared_displacement
#@  
#@ !------ A. Garhammer 2016------
#@ subroutine get_displacement(particle_id,return_displacement)
#@ !****f* base_acf/get_displacement
#@ ! FUNCTION
#@ !    Returns displacement for a particle of the tracked species.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``particle_id`` positive integer that represents the id of a particle. 
#@ !    * ``return_displacement`` writeable 3 dimensonal array, where the displacement of a particle will be stored.
#@ !******
#@ !---------------I/O variables--------------- 
#@ integer(kind=iint), intent(in) :: particle_id
#@ real(kind=rdouble), dimension(3),  intent(out) :: return_displacement
#@ 
#@ return_displacement = displacement(particle_id,:)
#@ 
#@ end subroutine get_displacement
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine allocate_tracing_arr(nr_of_types_arg)
#@ !****f* base_acf/allocate_tracing_arr
#@ ! FUNCTION
#@ !    Allocates the arrays for the calculation of the ACF.
#@ !    The most arrays start from index zero not from one. 
#@ !    In the cases of drain and source processes of the tracked species
#@ !    and diffusion processes of other species, one need dummy entries in the arrays at index zero.
#@ !    These entries remain zero all the time.
#@ !    Otherwise the tracking of the particles doesn't work in these cases.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``nr_of_types_arg`` positive integer that represents the number of different types of properties
#@ !******
#@ !---------------I/O variables--------------- 
#@ integer(kind = iint), intent(in) :: nr_of_types_arg
#@ integer(kind = iint) :: volume
#@ 
#@ call get_volume(volume)
#@ nr_of_types = nr_of_types_arg
#@ 
#@ allocate(types(nr_of_types))
#@ types = 0
#@ 
#@ allocate(property_acf(0:volume))
#@ property_acf = 0
#@ 
#@ allocate(property_o(0:volume))
#@ property_o = 0
#@ 
#@ allocate(product_property(0:nr_of_types,0:nr_of_types))
#@ product_property = 0
#@ 
#@ allocate(id_arr(0:volume))
#@ id_arr = 0
#@ 
#@ allocate(site_arr(0:volume))
#@ site_arr = 0
#@ 
#@ allocate(buffer_acf(0:volume))
#@ buffer_acf = 0
#@  
#@ end subroutine allocate_tracing_arr
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine allocate_trajectory(nr_of_steps_arg)
#@ !****f* base_acf/allocate_trajectory
#@ ! FUNCTION
#@ !    Allocates and intializes the trajecotry array.
#@ !    The array trajectory starts from index zero.
#@ !    In the case of diffusion processes of other species than the tracked species, 
#@ !    one need a dummy entry of the value zero at index zero to record the trajectory.
#@ !    This dummy entry at index zero remains zero all the time.
#@ !    Otherwise the record doesn't work.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``nr_of_steps_arg``, postive integer that represents the number of kMC steps,
#@ !      for which the trajectory is recorded.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind = iint), intent(in) :: nr_of_steps_arg
#@ integer(kind = iint) :: i
#@ 
#@ nr_of_steps = nr_of_steps_arg 
#@ 
#@ allocate(trajectory(0:nr_of_ions, nr_of_steps + 1))
#@ trajectory = 0
#@ 
#@ do i = 1 , nr_of_ions
#@ trajectory(i,1) = site_arr(i)
#@ enddo
#@
#@ kmc_step_acf = 0
#@ 
#@ end subroutine allocate_trajectory
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine allocate_config_bin_acf(t_bin_arg,t_f_arg,safety_factor_t_f_arg,extending_factor_arg)
#@ !****f* base_acf/allocate_config_bin_acf
#@ ! FUNCTION
#@ !    allocate_config_bin_acf allocates and initializes the arrays and the variables for the on the fly
#@ !    calculation of the autocorrelation function (ACF).
#@ !    The user must specify the bin size t_bin and the decorrelation time t_f to be used for calculating the ACF.
#@ !    From this, the number of bins is calculated.
#@ !    If the number of trash bins is too small and the time interval, which exceeds t_f too big, a segmentation fault occurs.
#@ !    This problem can be fixed by increasing the number of trash bin with extending_factor and starting the sampling of ACF again.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``t_bin_arg`` real representing the bin size.
#@ !    * ``t_f_arg`` real representing the decorrelation time.
#@ !    * ``safety_factor_t_f_arg`` positive integer that extends t_f
#@ !    * ``extending_factor_arg`` positive integer that extends the nr of bins
#@ !******
#@ !---------------I/O variables---------------
#@ real(kind = rdouble), intent(in) :: t_bin_arg
#@ real(kind = rdouble), intent(in) :: t_f_arg
#@ integer(kind = iint), intent(in), optional :: safety_factor_t_f_arg, extending_factor_arg
#@ integer(kind = iint) :: safety_factor_t_f, extending_factor
#@ real(kind = rdouble) :: kmc_time
#@ 
#@ call get_kmc_time(kmc_time)
#@  
#@ if(.not. present(safety_factor_t_f_arg) .or. safety_factor_t_f_arg.eq.0)then
#@ safety_factor_t_f = 2
#@ else
#@ safety_factor_t_f = safety_factor_t_f_arg
#@ end if
#@ 
#@ if(.not. present(extending_factor_arg) .or. extending_factor_arg.eq.0)then
#@ extending_factor = 2
#@ else
#@ extending_factor = extending_factor_arg
#@ end if
#@ t_f = t_f_arg * safety_factor_t_f
#@ t_bin = t_bin_arg
#@ nr_of_bins = int(t_f/t_bin + 1)
#@ extended_nr_of_bins = nr_of_bins * extending_factor
#@ t_f = nr_of_bins * t_bin
#@ allocate(config_bin(extended_nr_of_bins))
#@ config_bin = 0
#@ allocate(counter_write_in_bin(extended_nr_of_bins))
#@ counter_write_in_bin = 0
#@ bin_index = 0
#@ wrap_count = 0
#@ nr_of_annhilations = 0
#@ t_o = kmc_time
#@ 
#@ print *, "+------------------------------------------------------------+"
#@ print *, "|Decorrelation time|", t_f, "s"
#@ print *, "+------------------------------------------------------------+"
#@ print *, "|Number of bins for ACF|", nr_of_bins
#@ print *, "+------------------------------------------------------------+"
#@ print *, "|Total number of bins|", extended_nr_of_bins
#@ print *, "+------------------------------------------------------------+"
#@ print *, "|Safety factor decorrelation time|", safety_factor_t_f
#@ print *, "+------------------------------------------------------------+"
#@ print *, "|Extending factor number of bins|", extending_factor
#@ print *, "+------------------------------------------------------------+"
#@
#@ end subroutine allocate_config_bin_acf
#@
#@ !------ A. Garhammer 2016------
#@ subroutine set_acf_to_zero()
#@ !****f* base_acf/set_acf_to_zero
#@ ! FUNCTION
#@ !    Sets all acf arrays and parameters to initial state.
#@ !    After this, the sampling of the ACF can start from new.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``none``.
#@ !******
#@ !---------------I/O variables---------------
#@ real(kind = rdouble) :: kmc_time
#@ 
#@ call get_kmc_time(kmc_time)
#@ call update_nr_of_ions_before_kmc_step_acf() 
#@ call update_property_and_buffer_acf()  
#@
#@ config_bin = 0
#@ counter_write_in_bin = 0
#@ bin_index = 0
#@ wrap_count = 0
#@ nr_of_annhilations = 0
#@ t_o = kmc_time
#@ 
#@ end subroutine set_acf_to_zero
#@
#@ !------ A. Garhammer 2016------
#@ subroutine set_displacement_to_zero()
#@ !****f* base_acf/set_displacement_to_zero
#@ ! FUNCTION
#@ !    Sets displacement vector to zero.
#@ !    After this, the recording of the displacement can start
#@ !    from new.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``none``.
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ displacement = 0
#@ 
#@ end subroutine set_displacement_to_zero
#@
#@ !------ A. Garhammer 2016------
#@ subroutine get_config_bin_acf(bin_index,return_config_bin)
#@ !****f* base_acf/get_config_bin_acf
#@ ! FUNCTION
#@ !    Returns an entry of the array config_bin.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``bin_index`` positive integer that represents the bin index.
#@ !    * ``return_config_bin`` writeable real, in which the entry of a bin is stored .
#@ !******
#@ !---------------I/O variables--------------- 
#@ integer(kind=iint), intent(in) :: bin_index
#@ real(kind=rdouble), intent(out) :: return_config_bin
#@  
#@ return_config_bin = config_bin(bin_index)
#@ 
#@ end subroutine get_config_bin_acf
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine get_counter_write_in_bin(bin_index,return_counter_write_in_bin)
#@ !****f* base_acf/get_counter_write_in_bin
#@ ! FUNCTION
#@ !    Returns an entry of the array counter_write_in_bin.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``bin_index`` positive integer that represents the bin index.
#@ !    * ``return_counter_write_in_bin`` writeable integer, in which the number contributions of one bin is stored .
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind=iint), intent(in) :: bin_index
#@ real(kind=rdouble), intent(out) :: return_counter_write_in_bin
#@  
#@ return_counter_write_in_bin = counter_write_in_bin(bin_index)
#@ 
#@ end subroutine get_counter_write_in_bin 
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine set_property_acf(site_nr_acf,input_property_acf)
#@ !****f* base_acf/set_property_acf
#@ ! FUNCTION
#@ !    set_property_acf sets the property of each site for the calculation of ACF.
#@ !    The type index of the corresponding property will be stored in property_acf.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``site_nr_acf`` positive integer that represents the site indx.
#@ !    * ``input_property_acf`` real that represents the type index of the corresponding property .
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind=iint), intent(in) :: site_nr_acf
#@ integer(kind=iint), intent(in) :: input_property_acf
#@  
#@ property_acf(site_nr_acf) = input_property_acf
#@ 
#@ end subroutine set_property_acf
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine set_types(type_index,input_property)
#@ !****f* base_acf/set_types
#@ ! FUNCTION
#@ !    set_types sets all possible properties.
#@ !    The properties will be stored in types.
#@ !    The properties are defined by the user.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``type_index`` positive integer that represents the type index for a property.
#@ !    * ``input_property`` real that represents the property.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind=iint), intent(in) :: type_index
#@ real(kind=rdouble), intent(in) :: input_property
#@ 
#@ types(type_index) = input_property
#@ 
#@ end subroutine set_types
#@  
#@ !------ A. Garhammer 2016------
#@ subroutine set_product_property(type_index_o,type_index,input_product_property)
#@ !****f* base_acf/set_product_property
#@ ! FUNCTION
#@ !    set_product_property sets all possible combination of products of properties.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``type_index_o`` positive integer that represents the type index of the initial property.
#@ !    * ``type_index`` positve integer that represents the type index of a property.
#@ !    * ``input_product_property`` real that represents the product of two properties.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind=iint), intent(in) :: type_index_o
#@ integer(kind=iint), intent(in) :: type_index
#@ real(kind=rdouble), intent(in) :: input_product_property
#@ 
#@ product_property(type_index_o,type_index) = input_product_property
#@ 
#@ end subroutine set_product_property
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine get_property_acf(site,return_property_acf)
#@ !****f* base_acf/get_property_acf
#@ ! FUNCTION
#@ !    Returns an entry of the array property_acf.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``site`` positive integer that represents the site index.
#@ !    * ``return_property_acf`` writeable integer, where an entry of property_acf will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind=iint), intent(in) :: site
#@ integer(kind=iint), intent(out) :: return_property_acf
#@ 
#@ return_property_acf = property_acf(site)
#@ 
#@ end subroutine get_property_acf
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine get_types(type_index,return_types)
#@ !****f* base_acf/get_types
#@ ! FUNCTION
#@ !    Returns an entry of the array types.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``type_index`` positive integer that represents the type index.
#@ !    * ``return_types`` writeable real, where the property of the corresponding type index will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind=iint), intent(in) :: type_index
#@ real(kind=rdouble), intent(out) :: return_types
#@ 
#@ return_types = types(type_index)
#@  
#@ end subroutine get_types
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine get_product_property(type_index_o,type_index,return_product_property)
#@ !****f* base_acf/get_product_property
#@ ! FUNCTION
#@ !    Returns an entry of the array product_property.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``type_index_o`` positive integer that represents the type index of the initial property.
#@ !    * ``type_index`` positve integer that represents the type index of a property.   
#@ !    * ``return_product_property`` writeable real, where an entry of product_property will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind=iint), intent(in) :: type_index_o, type_index
#@ real(kind=rdouble), intent(out) :: return_product_property
#@  
#@ return_product_property = product_property(type_index_o,type_index)
#@ 
#@ end subroutine get_product_property
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine get_property_o(particle_id,return_property_o)
#@ !****f* base_acf/get_property_o
#@ ! FUNCTION
#@ !    Returns an entry of the array property_o.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``particle_id`` positive integer that represents id of a particle. 
#@ !    * ``return_property_o`` writeable real, where an entry of property_o will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind=iint), intent(in) :: particle_id
#@ integer(kind=iint), intent(out) :: return_property_o
#@ 
#@ return_property_o = property_o(particle_id)
#@ 
#@ end subroutine get_property_o
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine get_buffer_acf(particle_id,return_buffer_acf)
#@ !****f* base_acf/get_buffer_acf
#@ ! FUNCTION
#@ !    Returns an entry of the array buffer_acf.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``particle_id`` positive integer that represents id of a particle.
#@ !    * ``return_buffer_acf`` writeable real, where an entry of buffer_acf will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind=iint), intent(in) :: particle_id 
#@ real(kind=rdouble), intent(out) :: return_buffer_acf
#@ 
#@ return_buffer_acf = buffer_acf(particle_id)
#@ 
#@ end subroutine get_buffer_acf
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine get_id_arr(site,return_id_arr)
#@ !****f* base_acf/get_id_arr
#@ ! FUNCTION
#@ !    Returns an entry of the array id_arr.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``site`` positive integer that represents the site index.
#@ !    * ``return_id_arr`` writeable integer, where an entry of id_arr will be stored.
#@ !******
#@ !---------------I/O variables--------------- 
#@ integer(kind=iint), intent(in) :: site
#@ integer(kind=iint), intent(out) :: return_id_arr
#@ 
#@ return_id_arr = id_arr(site)
#@ 
#@ end subroutine get_id_arr
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine get_site_arr(particle_id,return_site_arr)
#@ !****f* base_acf/get_site_arr
#@ ! FUNCTION
#@ !    Returns an entry of the array site_arr.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``particle_id`` positive integer that represents the id of a particle.
#@ !    * ``return_site_arr`` writeable integer, where an entry of site_arr will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind=iint), intent(in) :: particle_id 
#@ integer(kind=iint), intent(out) :: return_site_arr
#@ 
#@ return_site_arr = site_arr(particle_id)
#@ 
#@ end subroutine get_site_arr
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine get_trajectory(particle_id,kmc_step,return_trajectory)
#@ !****f* base_acf/get_trajectory
#@ ! FUNCTION
#@ !    Returns an entry of the array trajectory.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``particle_id`` positive integer that represents the id of a particle.
#@ !    * ``kmc_step`` positive integer that represents the number of kMC steps.
#@ !    * ``return_trajectory`` writeable integer, where an entry of trajectory  will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind=iint), intent(in) :: particle_id,kmc_step
#@ integer(kind=iint), intent(out) :: return_trajectory
#@ 
#@ return_trajectory = trajectory(particle_id,kmc_step)
#@ 
#@ end subroutine get_trajectory
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine update_trajectory(particle_id, kmc_step_acf)
#@ !****f* base/update_trajectory
#@ ! FUNCTION
#@ !    update_trajectory saves for each particle the site index after one kmc step.
#@ !    This function is optional and can be turned on and off.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``particle_id`` positive integer that represents the id of the jumping particle.
#@ !    * ``kmc_step_acf`` positive integer that represents the number of kMC steps which were executed
#@ !        for the recording of the trajectory.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind = iint), intent(in) :: particle_id
#@ integer(kind = ilong), intent(in) :: kmc_step_acf
#@  
#@ trajectory(:,kmc_step_acf+1) = trajectory(:,kmc_step_acf)
#@ trajectory(particle_id,kmc_step_acf+1) = site_arr(particle_id)
#@ 
#@ end subroutine update_trajectory
#@  
#@ !------ A. Garhammer 2015------
#@ subroutine assign_particle_id(init_site,particle_id)
#@ !****f* base_acf/assign_particle_id
#@ ! FUNCTION
#@ !    assign_particle_id gives the id of the jumping particle in one kmc step.
#@ !    In the case of an exit process of the particle with the highest id,
#@ !    the output for particle_id is zero. Also for a hop of a particle of  
#@ !    other species than the tracked species. Therefore, the arrays for the 
#@ !    tracking process and for the sampling of ACF or MSD start with index zero.
#@ !    The entries at this index are dummy values.   
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``particle_id`` positive integer that represents the id of the jumping particle.
#@ !    * ``init_site`` positive integer that represents the index of the site, which is occupied by the particle
#@ !        before a process happens.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind = iint) :: k
#@ integer(kind = iint), intent(out) :: particle_id
#@ integer(kind = iint), intent(in) :: init_site
#@ 
#@ particle_id = id_arr(init_site)
#@ 
#@ end subroutine assign_particle_id
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine update_displacement(particle_id,displace_coord)
#@ !****f* base_acf/update_displacement
#@ ! FUNCTION
#@ !    update_displacement updates the displacement of the jumping particle in one kmc step.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``particle_id`` positive integer that represents the id of the jumping particle.
#@ !    * ``displace_coord`` 3 dimensonal array, where the displacement of the jumping particle will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind = iint), intent(in) :: particle_id
#@ real(kind = rdouble), dimension(3), intent(in) :: displace_coord
#@  
#@ displacement(particle_id,:) = displacement(particle_id,:) + displace_coord
#@ 
#@ end subroutine update_displacement
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine calc_mean_squared_disp(mean_squared_disp)
#@ !****f* base_acf/calc_mean_squared_disp
#@ ! FUNCTION
#@ !   calc_mean_squared_disp calculates the mean squared displacement after a kmc run.
#@ !   The user have to call this subroutine after the kmc run, to get the mean squared displacement.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``mean_squared_disp`` writeable real, where the mean squared displacement will be stored.
#@ !******
#@ !---------------I/O variables--------------- 
#@ integer(kind = iint) :: k
#@ real(kind = rdouble), intent(out) :: mean_squared_disp
#@ 
#@ mean_squared_disp = 0
#@ k = 1
#@ do k = 1, nr_of_ions
#@ mean_squared_disp = mean_squared_disp + sum(displacement(k,:)**2)
#@ enddo
#@ 
#@ mean_squared_disp = mean_squared_disp / nr_of_ions
#@ 
#@ end subroutine calc_mean_squared_disp
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine calc_acf(bin_index,return_acf)
#@ !****f* base_acf/calc_acf
#@ ! FUNCTION
#@ !   calc_acf calculates ACF after a kmc run.
#@ !   The user have to call this subroutine after the kmc run, to get the ACF.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``bin_index`` positive integer that represents the bin index.
#@ !    * ``return_acf`` writeable real, where an entry of the ACF will be stored.
#@ !******
#@ !---------------I/O variables--------------- 
#@ integer(kind=iint), intent(in) :: bin_index
#@ real(kind = rdouble), intent(out) :: return_acf
#@  
#@ return_acf = config_bin(bin_index)/(wrap_count*t_bin)
#@ 
#@ end subroutine calc_acf
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine update_id_arr(particle_id,init_site,fin_site)
#@ !****f* base_acf/update_id_arr
#@ ! FUNCTION
#@ !    update_id_arr updates id_arr after one kmc step.
#@ !    The id of the jumping particle is stored in the entry of the id_arr 
#@ !    which corresponds to the site index, which is occupied by this particle after the jump.
#@ !    The entry of the id_arr, which corresponds to the site index,
#@ !    which is occupied by this particle before the jump, is setted to zero.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``particle_id`` positive integer that represents the id of the jumping particle.
#@ !    * ``init_site`` positive integer that represents the index of the site, which is occupied by the particle
#@ !        before a process happens.
#@ !    * ``fin_site`` positive integer that represents the index of the site, which is occupied by the particle
#@ !        after a process.
#@ !******
#@ !---------------I/O variables--------------- 
#@ integer(kind = iint), intent(in) :: particle_id
#@ integer(kind = iint), intent(in) :: fin_site
#@ integer(kind = iint), intent(in) :: init_site
#@ 
#@ id_arr(init_site) = 0
#@ id_arr(fin_site) = particle_id
#@ site_arr(particle_id) = fin_site
#@ site_arr(0) = 0
#@ 
#@ end subroutine update_id_arr
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine drain_process(exit_site, init_site, fin_site)
#@ !****f* base_acf/drain_process
#@ ! FUNCTION
#@ !    drain_process updates the arrays for the tracking process and for the sampling of the autocorrelation function (ACF) as follows:
#@ !    In the case of an exit process (a particle leaves the system), the entries of the arrays which correspond to the particle
#@ !    which leaves the system are replaced by the entries of the particle with the highest id (the particle with the highest id becomes
#@ !    the id of the particle which exits the system). If a particle exits the system with an id that is smaller than the highest id
#@ !    in the system, the output for init_site and fin_site is the site index that corresponds to the site which is occupied by the particle 
#@ !    with the highest id and the tracking process works as usual. The tracking process updates the entries of the arrays which correspond to 
#@ !    to this particle with the same values as before.
#@ !    If the particle with the highest id exits the system, the output of init_site and fin_site is zero. In this case the tracking process 
#@ !    updates the entries for the particle with id zero, which doesn't exist. This is the reason why the arrays for the tracking process
#@ !    and for the sampling of the ACF have to start with index zero. The value for these entries at index zero is always zero.
#@ !    Furthermore, the real number of ions (nr_of_ions) which correspond to the tracked species has to be updated and also the number of ions 
#@ !    (nr_of_ions_before_kmc_step_acf) which contribute to the ACF. If a particle enters the system within the decorrelation time, this particle 
#@ !    doesn't contribute to the ACF. It contributes only after a wrap (decorrelation time was reached), if the particle is still in the system.       
#@ !    Nevertheless, if a particle enters the system within the decorrelation time, it will be tracked, but the entry for this particle in the array
#@ !    property_o is zero. Therefore, it has no contribution to the ACF and nr_of_ions_before_kmc_step_acf has the same value as before the kMC step. 
#@ !          
#@ ! ARGUMENTS
#@ !
#@ !    * ``exit_site`` positive integer that represents the index of the site from which the particle is taken.
#@ !    * ``init_site`` positive integer that represents the index of the site, which is occupied by the particle
#@ !        before a process happens.
#@ !    * ``fin_site`` positive integer that represents the index of the site, which is occupied by the particle
#@ !        after a process.
#@ !******
#@ !---------------I/O variables--------------- 
#@ integer(kind = iint) :: particle_id
#@ integer(kind = iint), intent(in) :: exit_site
#@ integer(kind = iint), intent(out) :: init_site, fin_site
#@ 
#@ particle_id = id_arr(exit_site)
#@ site_arr(particle_id) = site_arr(nr_of_ions)
#@  
#@ id_arr(site_arr(particle_id)) = particle_id
#@ site_arr(nr_of_ions) = 0
#@ id_arr(exit_site) = 0
#@ if( property_o(particle_id).ne.0 )then
#@    nr_of_ions_before_kmc_step_acf = nr_of_ions_before_kmc_step_acf - 1 
#@ endif
#@ property_o(particle_id) = property_o(nr_of_ions)
#@ property_o(nr_of_ions) = 0
#@ init_site = site_arr(particle_id)
#@ fin_site = site_arr(particle_id)
#@ buffer_acf(particle_id) = buffer_acf(nr_of_ions)
#@ buffer_acf(nr_of_ions) = 0
#@ nr_of_ions = nr_of_ions - 1
#@ nr_of_annhilations = nr_of_annhilations + 1
#@ 
#@ end subroutine drain_process
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine source_process(entry_site, init_site, fin_site)
#@ !****f* base_acf/source_process
#@ ! FUNCTION
#@ !    source_process updates the arrays for the tracking process and for the sampling of the autocorrelation function (ACF) as follows:
#@ !    In the case of an entry process (a particle enters the system), the particle which enters the system becomes the particle with the
#@ !    highest id in the system.
#@ !    Furthermore, the real number of ions (nr_of_ions) which correspond to the tracked species has to be updated. If a particle enters
#@ !    the system within the decorrelation time, this particle doesn't contribute to the ACF. It contributes only after a wrap
#@ !    (decorrelation time was reached), if the particle is still in the system.       
#@ !    Nevertheless, if a particle enters the system within the decorrelation time, it will be tracked, but the entry for this particle in the array
#@ !    property_o is zero. Therefore, it has no contribution to the ACF and nr_of_ions_before_kmc_step_acf has the same value as before the kMC step.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``entry_site`` positive integer that represents the index of the site on which the particle is put.
#@ !    * ``init_site`` positive integer that represents the index of the site, which is occupied by the particle
#@ !        before a process happens.
#@ !    * ``fin_site`` positive integer that represents the index of the site, which is occupied by the particle
#@ !        after a process.
#@ !******
#@ !---------------I/O variables--------------- 
#@ integer(kind = iint), intent(in) :: entry_site
#@ integer(kind = iint), intent(out) :: init_site, fin_site
#@  
#@ nr_of_ions = nr_of_ions + 1
#@ id_arr(entry_site) = nr_of_ions
#@ site_arr(nr_of_ions) = entry_site
#@ fin_site = entry_site
#@ init_site = entry_site
#@ 
#@ end subroutine source_process
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine update_buffer_acf(particle_id)
#@ !****f* base_acf/update_buffer_acf
#@ ! FUNCTION
#@ !    update_buffer_acf updates the buffer_acf array. This array contains for each particle id of the tracked species the current product (g(0)g(t))
#@ !    of the property_o (g(0)) and the current property (g(t)). For an id that doesn't contribute to the ACF (entry of a particle within the
#@ !    decorrelation time) the entry at this index (id) is zero. In the case of an exit process of the particle with the highest id or a hop of
#@ !    other species than the tracked species, the dummy entry (value zero) at index zero of the array buffer_acf is used. Because the particle id
#@ !    has the value zero in these cases. Also, the arrays product_property, property_o, property_acf and site_arr need a dummy entry of value zero
#@ !    at index zero.    
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``particle_id`` positive integer that represents the id of the jumping particle.
#@ !******
#@ !---------------I/O variables--------------- 
#@ integer(kind = iint), intent(in) :: particle_id
#@ 
#@ buffer_acf(particle_id) = product_property(property_o(particle_id),property_acf(site_arr(particle_id)))
#@  
#@ end subroutine update_buffer_acf
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine update_property_and_buffer_acf()
#@ !****f* base_acf/update_property_and_buffer_acf
#@ ! FUNCTION
#@ !    update_property_and_buffer_acf initializes the arrays propert_o and buffer_acf in the beginning
#@ !    of ACF sampling and after a wrap (correlation time t_f was reached).
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``none``
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind = iint) :: i, volume
#@ 
#@ call get_volume(volume)
#@ 
#@ do i = 1, volume
#@ property_o(i) = property_acf(site_arr(i))
#@ buffer_acf(i) = product_property(property_o(i),property_o(i))
#@ enddo
#@ 
#@ end subroutine update_property_and_buffer_acf
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine update_config_bin()
#@ !****f* base_acf/update_config_bin
#@ ! FUNCTION
#@ !    update_config_bin updates the config_bin and the counter_write_in_bin arrays as follows:
#@ !    The timeline is divided into bins with the size t_bin. The borders of this timeline are
#@ !    t_o (start time for ACF sampling of one wrap) and t_f (decorrelation time of one wrap).
#@ !    The number of bins is calculated by int((t_f/t_o)+1) and the bin_index starts at zero.
#@ !    After a kMC step was executed, a exponentially distributed time interval was generated
#@ !    and was added to the kmc_time. update_config_bin checks which bins correspond to this
#@ !    new time and stores the corresponding entries (g(0)g(t)) to the right bins.
#@ !    These entries depend on the last configuration of the system. A entry of a bin is
#@ !    calculated by the sum of the buffer_acf array and by the division of this sum by the
#@ !    number of ions which contribute to the ACF within one decorrelation time t_f (one wrap).
#@ !    For a correct evaluation of the integral of the ACF, a entry of a bin has to be weighted
#@ !    by the right fraction of the bin size. 
#@ !    To avoid too many if conditions, the config_bin array has more than int((t_f/t_o)+1)
#@ !    bins. These additonal bins are trash bins and don't have a meaning for the ACF. 
#@ !    If the kmc_time exceeds the decorrelation time t_f, the binning process uses the whole
#@ !    time interval, which was generated by the corresponding kMC step. Therefore, the trash
#@ !    bins are needed. If the number of trash bins is too small and the time interval,
#@ !    which exceeds t_f too big, a segmentation fault occurs. This problem can be fixed by
#@ !    increasing the number of trash bin with extending_factor in allocate_config_bin_acf
#@ !    and starting the sampling of ACF again.  
#@ !    After the exeedance of t_f, the new start time t_o is equal to the current kmc_time and
#@ !    also the intial configuration is the configuration at this kmc_time, which exceeds t_f.
#@ !    The bin index is set to zero, the property_o array is updated and the binning process
#@ !    starts again. To get a good statistic, it is necessary to have a lot of wraps. In the
#@ !    case of entry and exit processes, the number of annhilations (particle exit the system)
#@ !    should be significantly smaller than the number of wraps. Otherwise too few particles 
#@ !    contribute to the ACF and the statistic will be bad.
#@ !    Furthermore, the number of contributions for each bin is saved in the array
#@ !    config_write_in_bin.   
#@ !    
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``none``
#@ !******
#@ !---------------I/O variables---------------
#@ real(kind = rdouble) :: entry_bin, kmc_time, kmc_time_step
#@ 
#@ call get_kmc_time(kmc_time)
#@ call get_kmc_time_step(kmc_time_step)
#@ 
#@ entry_bin = sum(buffer_acf)
#@ if(entry_bin.eq.0)then
#@ entry_bin = 0
#@ else
#@ entry_bin = entry_bin/nr_of_ions_before_kmc_step_acf
#@ endif
#@  
#@ if(kmc_time - t_o < (bin_index + 1) * t_bin)then
#@ config_bin(bin_index + 1) = config_bin(bin_index + 1) + entry_bin * kmc_time_step
#@ counter_write_in_bin(bin_index + 1) = counter_write_in_bin(bin_index + 1) + 1
#@ else
#@ 
#@ config_bin(bin_index + 1) = config_bin(bin_index + 1) + entry_bin * ((bin_index + 1) * t_bin - (kmc_time - t_o - kmc_time_step))
#@ counter_write_in_bin(bin_index + 1) = counter_write_in_bin(bin_index + 1) + 1
#@ bin_index = bin_index + 1
#@ if(bin_index < nr_of_bins)then
#@ do while((bin_index + 1) * t_bin < kmc_time - t_o)
#@ 
#@ config_bin(bin_index + 1) = config_bin(bin_index + 1) + entry_bin * t_bin
#@ counter_write_in_bin(bin_index + 1) = counter_write_in_bin(bin_index + 1) + 1
#@ bin_index = bin_index + 1
#@ 
#@ enddo
#@
#@ config_bin(bin_index + 1) = config_bin(bin_index + 1) + entry_bin * (kmc_time - t_o - (bin_index * t_bin))
#@ counter_write_in_bin(bin_index + 1) = counter_write_in_bin(bin_index + 1) + 1
#@ 
#@ end if
#@ end if
#@ 
#@ end subroutine update_config_bin
#@ 
#@ subroutine update_after_wrap_acf()
#@ !****f* base_acf/update_after_wrap_acf
#@ ! FUNCTION
#@ !    update_after_wrap_acf checks if the current kmc_time exceeds the decorrelation time t_f.
#@ !    If this is the case, the bin index is set to zero, t_o is set to the current kmc_time,
#@ !    the number of wraps is increased by one and the number of ions, which contribute to the ACF
#@ !    is updated with the new intial configuration. Also, the property_o and the buffer_acf arrays  
#@ !    are updated with the new inital configuration. 
#@ !    After this, a new wrap starts.
#@ ! ARGUMENTS
#@ !
#@ !    * ``none``
#@ !******
#@ !---------------I/O variables--------------- 
#@ real(kind = rdouble) :: kmc_time
#@ 
#@ call get_kmc_time(kmc_time)
#@ 
#@ if(bin_index > nr_of_bins - 1)then
#@ t_o = kmc_time
#@ bin_index = 0
#@ wrap_count = wrap_count + 1
#@ call update_property_and_buffer_acf()
#@ call update_nr_of_ions_before_kmc_step_acf()
#@ end if
#@ 
#@ end subroutine update_after_wrap_acf 
#@
#@ !------ A. Garhammer 2015------
#@ subroutine update_kmc_step_acf()
#@ !****f* base_acf/update_kmc_step_acf
#@ ! FUNCTION
#@ !    Updates kmc_step_acf.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``none``
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ kmc_step_acf = kmc_step_acf + 1
#@ 
#@ end subroutine update_kmc_step_acf
#@
#@ !------ A. Garhammer 2015------
#@ subroutine get_kmc_step_acf(return_kmc_step_acf)
#@ !****f* base_acf/get_kmc_step_acf
#@ ! FUNCTION
#@ !    Return the current kmc_step_acf
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``return_kmc_step_acf`` Writeable integer
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind=ilong), intent(out) :: return_kmc_step_acf
#@ 
#@ return_kmc_step_acf = kmc_step_acf
#@ 
#@ end subroutine get_kmc_step_acf
#@
#@ !------ A. Garhammer 2016------
#@ subroutine deallocate_acf()
#@ !****f* base_acf/deallocate_acf
#@ ! FUNCTION
#@ !    Deallocate all allocatable arrays: id_arr, site_arr, displacement,
#@ !    property_acf, property_o, types, product_property, trajectory,
#@ !    buffer_acf, config_bin, counter_write_in_bin
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    ``none``
#@ !******
#@ if(allocated(id_arr))then
#@     deallocate(id_arr)
#@ else
#@     print *,"Warning: id_arr was not allocated, tried to deallocate."
#@ endif
#@ if(allocated(site_arr))then
#@     deallocate(site_arr)
#@ else
#@     print *,"Warning: site_arr was not allocated, tried to deallocate."
#@ endif
#@ if(allocated(displacement))then
#@     deallocate(displacement)
#@ else
#@     print *,"Warning: displacement was not allocated, tried to deallocate."
#@ endif
#@ if(allocated(property_acf))then
#@     deallocate(property_acf)
#@ else
#@     print *,"Warning: property_acf was not allocated, tried to deallocate."
#@ endif
#@ if(allocated(property_o))then
#@     deallocate(property_o)
#@ else
#@     print *,"Warning: property_o was not allocated, tried to deallocate."
#@ endif
#@ if(allocated(types))then
#@     deallocate(types)
#@ else
#@     print *,"Warning: types was not allocated, tried to deallocate."
#@ endif
#@ if(allocated(product_property))then
#@     deallocate(product_property)
#@ else
#@     print *,"Warning: product_property was not allocated, tried to deallocate."
#@ endif
#@ if(allocated(trajectory))then
#@     deallocate(trajectory)
#@ else
#@     print *,"Warning: trajectory was not allocated, tried to deallocate."
#@ endif
#@ if(allocated(buffer_acf))then
#@     deallocate(buffer_acf)
#@ else
#@     print *,"Warning: buffer_acf was not allocated, tried to deallocate."
#@ endif
#@ if(allocated(config_bin))then
#@     deallocate(config_bin)
#@ else
#@     print *,"Warning: config_bin was not allocated, tried to deallocate."
#@ endif
#@ if(allocated(counter_write_in_bin))then
#@     deallocate(counter_write_in_bin)
#@ else
#@     print *,"Warning: counter_write_in_bin was not allocated, tried to deallocate."
#@ endif
#@
#@ end subroutine deallocate_acf
#@ 
#@ 
#@ end module base_acf
